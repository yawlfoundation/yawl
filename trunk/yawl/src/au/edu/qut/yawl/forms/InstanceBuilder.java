/*
 * This file is made available under the terms of the LGPL licence.
 * This licence can be retreived from http://www.gnu.org/copyleft/lesser.html.
 * The source remains the property of the YAWL Foundation.  The YAWL Foundation is a collaboration of
 * individuals and organisations who are commited to improving workflow technology.
 *
 */


package au.edu.qut.yawl.forms;

import org.apache.xml.serialize.OutputFormat;
import org.apache.xml.serialize.XMLSerializer;
import org.w3c.dom.*;
import org.w3c.dom.traversal.DocumentTraversal;
import org.w3c.dom.traversal.NodeFilter;
import org.w3c.dom.traversal.NodeIterator;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.FactoryConfigurationError;
import javax.xml.parsers.ParserConfigurationException;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;


/**
 * @author Guy Redding 7/05/2004
 *
 */
public class InstanceBuilder {

    private static boolean debug = false;

    private String root = null;


    /**
     * Builds a populated XML instance given an empty instance and data from YAWL in the
     * YParametersSchema class.
     * @param schemaName The name of the newly created (temporary) schema file.
     * @param instanceName The name of the newly created (temporary) instance file.
     * @param sessionHandle The session handle for the current YAWL session.
     * @param _root
     */
    public InstanceBuilder(String schemaName, String schemaPath, String instanceName,
                           String instancePath, String sessionHandle, String _root) {

        if (debug) {
            System.out.println("InstanceBuilder INSTANCE: " + instanceName + " ROOT: " + _root);
        }

        root = _root;

        domCreation(schemaName, schemaPath, instanceName, instancePath);
    }


    /**
     * Creates an empty DOM instance from a schema file,
     * then populates the DOM instance with data from YAWL.
     * @param schemaFileName Name of the file to read the xsd schema from.
     * @param instanceFileName Name of the file to write the xml instance to.
     */
    public void domCreation(String schemaFileName, String schemaFilePath,
                            String instanceFileName, String instanceFilePath) {

        Document document = null;
        Document instanceS = null;
        Document instanceI = null;

        // read existing schema from file
        try {
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            //factory.setValidating(true);
            //factory.setNamespaceAware(true);

            // parse schema
            document = builder.parse(schemaFilePath);

            DOMImplementation impl = builder.getDOMImplementation();
            instanceS = impl.createDocument(null, root, null);
            Element rootElement = instanceS.getDocumentElement();

            // start recursive parse of the schema DOM
            nodeDetails(document, instanceS, rootElement);
        } catch (FactoryConfigurationError e) {
            System.out.println("Factory Configuration Error: " + e.toString());
        } catch (ParserConfigurationException e) {
            System.out.println("Parser Configuration Error: " + e.toString());
        } catch (SAXException e) {
            System.out.println("SAX Exception: " + e.toString());
        } catch (IOException e) {
            System.out.println("IO Exception: " + e.toString());
        }


        // read instance from file
        try {
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            instanceI = builder.parse(new File(instanceFilePath));
        } catch (SAXParseException spe) {
            // Error generated by the parser
            System.out.println("\n** Parsing error" + ", line " + spe.getLineNumber() + ", uri " + spe.getSystemId());
            System.out.println(" " + spe.getMessage());
            // Use the contained exception, if any
            Exception x = spe;
            if (spe.getException() != null)
                x = spe.getException();
            x.printStackTrace();
        } catch (SAXException sxe) {
            // Error generated during parsing
            Exception x = sxe;
            if (sxe.getException() != null)
                x = sxe.getException();
            x.printStackTrace();
        } catch (ParserConfigurationException pce) {
            pce.printStackTrace();
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }

        // overwrite any matching elements in the empty instance with
        // elements contained in this input instance

        // Create NodeIterators for both the "empty" and "input" instance documents
        // must have DOM level 2 for DocumentTraversal.
        DocumentTraversal traversableS = (DocumentTraversal) instanceS;
        NodeIterator iteratorS = traversableS.createNodeIterator(instanceS, NodeFilter.SHOW_ALL, null, true);

        // Iterate over the instance
        Node nodeS;
        Node nodeI;
        boolean found = false;

        while ((nodeS = iteratorS.nextNode()) != null) {
            if (debug) {
                System.out.println("nodeS: " + nodeS.getNodeName());
            }

            if (nodeS.getNodeName().compareTo(root) != 0) { // ignore root element

                DocumentTraversal traversableI = (DocumentTraversal) instanceI;
                NodeIterator iteratorI = traversableI.createNodeIterator(instanceI, NodeFilter.SHOW_ELEMENT, null, true);

                if (found == true) {
                    found = false;
                }

                while (((nodeI = iteratorI.nextNode()) != null) && (found == false)) {

                    // if the nodeName for this instance node matches an elements attribute in the schema,
                    // overwrite the text value of that node with the text from this node
                    if (nodeI.getNodeName().compareTo(nodeS.getNodeName()) == 0) {

                        try {
                            Node newNode = instanceS.importNode(nodeI, true);
                            instanceS.getDocumentElement().replaceChild(newNode, nodeS);

                            found = true;

                        } catch (DOMException e) {
                            System.out.println("DOM Error: ");
                            e.printStackTrace();
                        }
                    }
                }
            }
        }

        BufferedWriter bw = null;

        // create XForm (over)writer
        try {
            if (debug) {
                System.out.println("IB instanceFilePath: " + instanceFilePath);
            }
            bw = new BufferedWriter(new FileWriter(instanceFilePath, false));
        } catch (IOException e) {
            System.out.println("--IO file error: " + e.toString());
        }

        // write new XML instance
        try {
            OutputFormat format = new OutputFormat(instanceS);
            XMLSerializer output = new XMLSerializer(bw, format);
            output.serialize(instanceS);
        } catch (IOException e) {
            System.out.println(e);
        }

    }


    /**
     * A recursive function to traverse and mutate the schema document tree,
     * to create an XML instance that contains YAWL data.
     * @param node The currently referenced Node in the original schema Document.
     * @param instanceDoc The original schema Document.
     * @param instanceElement The instance Document.
     */
    private void nodeDetails(Node node, Document instanceDoc, Element instanceElement) {
        String Content = "";
        int type = node.getNodeType();
        boolean isQualifiedForm = false;
        boolean isType = false;

        // check if element
        if (type == Node.ELEMENT_NODE) {
            if (debug) {
                System.out.println("Element: " + node.getNodeName());
            }

            // if the element is a simpleType or complexType do not include it
            // because this is the empty-instance generation which does not
            // require simple or complex type node names in it.
            if (node.getNodeName().compareTo("xsd:simpleType") == 0 || node.getNodeName().compareTo("xsd:complexType") == 0) {
                isType = true;
            }

            // check if the node has any attributes, important for filtering out
            // anonymous complex types, which we don't want to add
            if (node.hasAttributes() == true && isType == false) {

                // if it does, store it in a NamedNodeMap object
                NamedNodeMap AttributesList = node.getAttributes();

                for (int j = 0; j < AttributesList.getLength(); j++) {
                    if (AttributesList.item(j).getNodeName().compareTo("form") == 0
                            && AttributesList.item(j).getNodeValue().compareTo("qualified") == 0) {
                        isQualifiedForm = true;
                    }
                }

                if (isQualifiedForm != true) {

                    // iterate through the NamedNodeMap and get the attribute names and values
                    for (int j = 0; j < AttributesList.getLength(); j++) {

                        // if the name attribute for this element is found and not the root element
                        if ((AttributesList.item(j).getNodeName().compareTo("name") == 0
                                || AttributesList.item(j).getNodeName().compareTo("ref") == 0)
                                && AttributesList.item(j).getNodeValue().compareTo(root) != 0) {

                            // create new element
                            Element e = instanceDoc.createElement(AttributesList.item(j).getNodeValue());
                            instanceElement.appendChild(e);

                            instanceElement = e;
                        }
                    }
                }
            }
        } else if (type == Node.TEXT_NODE) {
            // check if text node
            Content = node.getNodeValue();
            if (debug) {
                if (!Content.trim().equals("")) {
                    System.out.println("Character data: " + Content);
                } else {
                }
            }
        } else if (type == Node.COMMENT_NODE) {
            // check if comment node
            Content = node.getNodeValue();
            if (debug) {
                if (!Content.trim().equals("")) {
                    System.out.println("Comment: " + Content);
                }
            }
        }

        // check if current node has any children
        NodeList children = node.getChildNodes();

        if (children != null && isQualifiedForm == false) {
            // if it does, iterate through the collection
            for (int i = 0; i < children.getLength(); i++) {
                // recursively call function to proceed to next level
                nodeDetails(children.item(i), instanceDoc, instanceElement);
            }
        }
    }
}