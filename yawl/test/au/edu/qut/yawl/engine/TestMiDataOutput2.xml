<?xml version="1.0" encoding="UTF-8"?>
<specificationSet xmlns="http://www.citi.qut.edu.au/yawl"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="Beta 7.1"
	xmlns:mm="www.citi.qut.edu.au/yawl/exampleSchemas/make_trip_B"
	xsi:schemaLocation="http://www.citi.qut.edu.au/yawl YAWL_SchemaBeta7.1.xsd">
	<specification uri="TestMiDataOutput2.xml">
		<metaData/>
		<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
			attributeFormDefault="unqualified" elementFormDefault="qualified">
			<xs:complexType name="SongNameListType">
				<xs:sequence>
					<xs:element maxOccurs="unbounded" name="song" type="xs:string"/>
				</xs:sequence>
			</xs:complexType>
			<xs:simpleType name="FormatType">
				<xs:restriction base="xs:NMTOKEN">
					<xs:enumeration value="lp"/>
					<xs:enumeration value="album"/>
					<xs:enumeration value="double_album"/>
				</xs:restriction>
			</xs:simpleType>
			<xs:complexType name="SonglistType">
				<xs:sequence>
					<xs:element maxOccurs="unbounded" name="song" type="SongType"/>
				</xs:sequence>
			</xs:complexType>
			<xs:complexType name="SongType">
				<xs:sequence>
					<xs:element name="songName" type="xs:string"/>
					<xs:element name="songSpecification" type="xs:string"/>
					<!--
					<xs:element name="songLength" nillable="true"
						type="SonglengthType"/>
					<xs:element name="selected" nillable="true" type="xs:boolean"/>
					<xs:element name="sequenceNumber" type="xs:positiveInteger"/>
					-->
				</xs:sequence>
			</xs:complexType>
			<xs:complexType name="SonglengthType">
				<xs:sequence>
					<xs:element name="minutes" type="xs:nonNegativeInteger"/>
					<xs:element name="seconds">
						<xs:simpleType>
							<xs:restriction base="xs:nonNegativeInteger">
								<xs:maxInclusive value="59"/>
								<xs:minInclusive value="0"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:element>
				</xs:sequence>
			</xs:complexType>
			<xs:element name="crewMembers" type="CrewMembersType"/>
			<xs:element name="nameOfArtist" type="xs:string"/>
			<xs:element name="nameOfRecord" type="xs:string"/>
			<xs:complexType name="CrewMembersType">
				<xs:sequence>
					<xs:element maxOccurs="unbounded" name="memberName"
						type="xs:string"/>
				</xs:sequence>
			</xs:complexType>
		</xs:schema>
		<decomposition id="OverseeMusic" isRootNet="true" xsi:type="NetFactsType">
			<localVariable>
				<name>songlist</name>
				<type>SonglistType</type>
				<initialValue>&lt;song&gt;&lt;songName&gt;Song_1&lt;/songName&gt;
					&lt;songSpecification&gt;la la la, tra la-la la-la&lt;/songSpecification&gt;
					&lt;/song&gt;
					&lt;song&gt;&lt;songName&gt;Song_2&lt;/songName&gt;
					&lt;songSpecification&gt;fud, fud, fud,	dra da-da da-da&lt;/songSpecification&gt;
					&lt;/song&gt;
					&lt;song&gt;&lt;songName&gt;Song_3&lt;/songName&gt;
					&lt;songSpecification&gt;la la la, dra la-la da-da&lt;/songSpecification&gt;
					&lt;/song&gt;
					&lt;song&gt;&lt;songName&gt;Song_4&lt;/songName&gt;
					&lt;songSpecification&gt;la de da, tra la-la de-da&lt;/songSpecification&gt;
					&lt;/song&gt;</initialValue>
			</localVariable>
			<localVariable>
				<name>songList_output</name>
				<type>SongNameListType</type>
				<initialValue></initialValue>
			</localVariable>
			<processControlElements>
				<inputCondition id="input">
					<flowsInto>
						<nextElementRef id="record"/>
					</flowsInto>
				</inputCondition>
				<task id="record"
					xsi:type="MultipleInstanceExternalTaskFactsType">
					<flowsInto>
						<nextElementRef id="asdf"/>
					</flowsInto>
					<join code="xor"/>
					<split code="and"/>
					<decomposesTo id="Prepare"/>
					<minimum>1</minimum>
					<maximum>10</maximum>
					<threshold>4</threshold>
					<creationMode code="dynamic"/>
					<miDataInput>
						<expression
							query="&lt;songlist&gt; {if ( count(/OverseeMusic/songlist/*) &gt; 0) then ( for $d in /OverseeMusic/songlist/song return &lt;song&gt;{$d/songName}{$d/songSpecification}&lt;/song&gt; ) else /OverseeMusic/songList_backup/* }&lt;/songlist&gt;"/>
						<splittingExpression
							query="for $d in /songlist/* return &lt;songLocal&gt; { for $e in $d/* return $e } &lt;/songLocal&gt;"/>
						<formalInputParam>songLocal</formalInputParam>
					</miDataInput>
					<miDataOutput>
						<formalOutputExpression query="for $d in /Prepare/songLocal return &lt;song&gt;{$d/songName}{$d/songSpecification}&lt;/song&gt;"/>
						<!-- What should be: {$d/songName/text()} is {$d/songName} in the following query -->
						<outputJoiningExpression query="&lt;songList_output&gt; { for $d in /Prepare/song return &lt;song&gt;{$d/songName}&lt;/song&gt; } &lt;/songList_output&gt;"/>
						<resultAppliedToLocalVariable>songList_output</resultAppliedToLocalVariable>
					</miDataOutput>
				</task>
				<task id="asdf">
					<flowsInto>
						<nextElementRef id="finis"/>
					</flowsInto>
					<join code="or"/>
					<split code="and"/>
					<decomposesTo id="A"/>
				</task>
				<outputCondition id="finis">
					<name>Finished case</name>
				</outputCondition>
			</processControlElements>
		</decomposition>
		<decomposition id="Prepare" xsi:type="WebServiceGatewayFactsType">
			<inputParam>
				<name>songLocal</name>
				<type>SongType</type>
			</inputParam>
			<outputParam>
				<name>songLocal</name>
				<type>SongType</type>
			</outputParam>
		</decomposition>
		<decomposition id="A" xsi:type="WebServiceGatewayFactsType"/>
	</specification>
</specificationSet>